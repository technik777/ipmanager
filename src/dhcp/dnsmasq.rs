use anyhow::{Context, Result};
use chrono::{DateTime, Utc};
use serde::Serialize;
use serde_json::Value as JsonValue;
use sqlx::{FromRow, PgPool};
use std::os::unix::fs::PermissionsExt;
use std::path::Path;
use std::process::Command as StdCommand;
use std::str::FromStr;
use tokio::process::Command as TokioCommand;
use tokio::sync::Mutex;
use uuid::Uuid;

use crate::domain::mac::MacAddr;
use crate::integrations::macmon;
use crate::notifications::email;
use crate::pxe::{self, HostPxe};
const DNSMASQ_GLOBAL_CONFIG_PATH: &str = "/etc/dnsmasq.d/00-global.conf";

#[derive(Debug, Clone, Serialize)]
pub struct DnsmasqTestResult {
    pub ok: bool,
    pub stderr: Option<String>,
    pub at: DateTime<Utc>,
}

#[derive(Debug, Default, Clone, Serialize)]
pub struct DnsmasqStatus {
    pub last_test: Option<DnsmasqTestResult>,
    pub last_restart_at: Option<DateTime<Utc>>,
    pub warnings: Vec<String>,
}

#[derive(Debug, FromRow)]
struct HostRow {
    mac_address: String,
    ip_address: String,
    hostname: Option<String>,
    os_type: Option<String>,
    subnet_name: String,
    subnet_network_start: String,
    gateway: Option<String>,
    dns_primary: Option<String>,
    pxe_enabled: bool,
}

#[derive(Debug, FromRow)]
struct DhcpRangeRow {
    name: String,
    network_start: String,
    netmask: String,
    gateway: Option<String>,
    dns_primary: Option<String>,
    dns_zone: Option<String>,
    ntp_server: Option<String>,
}

pub async fn generate_global_config(pool: &PgPool, config: &crate::config::Config) -> Result<()> {
    let ranges: Vec<DhcpRangeRow> = match sqlx::query_as(
        "select name,
                host(network(cidr::inet)) as network_start,
                host(netmask(cidr::inet)) as netmask,
                gateway::text as gateway,
                dns_primary::text as dns_primary,
                dns_zone,
                ntp_server::text as ntp_server
         from subnets
         where dhcp_enabled = true
         order by name",
    )
    .fetch_all(pool)
    .await
    {
        Ok(rows) => rows,
        Err(e) => {
            tracing::error!(error = ?e, "failed to load DHCP ranges for dnsmasq");
            return Err(e).context("failed to load DHCP ranges for dnsmasq");
        }
    };

    let mut output = String::new();
    output.push_str("# Generated by ipmanager\n");
    output.push_str("listen-address=127.0.0.1,10.70.99.33\n");
    let interface = config
        .dnsmasq_interface
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .unwrap_or("ens33");
    output.push_str(&format!("interface={interface}\n"));
    output.push_str("bind-dynamic\n");
    output.push_str("no-dhcp-interface=lo\n");
    output.push_str("expand-hosts\n");
    output.push_str(&format!("domain={}\n", config.domain_name));
    output.push_str(&format!("local=/{}/\n", config.domain_name));
    output.push_str("domain-needed\n");
    output.push_str("bogus-priv\n");
    output.push_str("no-resolv\n");
    output.push_str("server=8.8.8.8\n");
    output.push_str("port=53\n");
    output.push_str("dhcp-authoritative\n");
    output.push_str("dhcp-ignore=tag:!known\n");

    if let Err(e) = tokio::fs::write(DNSMASQ_GLOBAL_CONFIG_PATH, output).await {
        tracing::error!(
            error = ?e,
            path = DNSMASQ_GLOBAL_CONFIG_PATH,
            "failed to write dnsmasq global config"
        );
        return Err(e).context("failed to write dnsmasq global config");
    }

    tracing::info!(
        path = DNSMASQ_GLOBAL_CONFIG_PATH,
        "dnsmasq global config written"
    );

    let conf_dir = Path::new(&config.dnsmasq_conf_dir);
    ensure_dnsmasq_conf_dir(conf_dir).await?;
    write_subnet_configs(&ranges, conf_dir, config).await?;

    Ok(())
}

pub async fn sync_dnsmasq_hosts(
    pool: &PgPool,
    config: &crate::config::Config,
    status: &Mutex<DnsmasqStatus>,
    user_id: Option<Uuid>,
) -> Result<()> {
    generate_global_config(pool, config).await?;
    check_infrastructure(Path::new(&config.tftp_root_dir)).await?;
    ensure_dnsmasq_conf_dir(Path::new(&config.dnsmasq_conf_dir)).await?;

    let hosts: Vec<HostRow> = match sqlx::query_as(
        "select h.mac_address::text as mac_address,
                h.ip_address,
                h.hostname,
                h.os_type,
                s.name as subnet_name,
                host(network(s.cidr::inet)) as subnet_network_start,
                s.gateway::text as gateway,
                s.dns_primary::text as dns_primary,
                h.pxe_enabled
         from hosts h
         join subnets s on s.id = h.subnet_id
         where s.dhcp_enabled = true
         order by s.name, h.hostname",
    )
    .fetch_all(pool)
    .await
    {
        Ok(rows) => rows,
        Err(e) => {
            tracing::error!(error = ?e, "failed to fetch hosts for dnsmasq sync");
            return Err(e).context("failed to fetch hosts for dnsmasq sync");
        }
    };

    clean_host_configs(Path::new(&config.dnsmasq_conf_dir)).await?;
    let assets_rel = assets_relative_path(config);
    let ipxe_boot = format!("{}/ipxe.efi", assets_rel);

    let mut warnings = Vec::new();
    let mut missing_assets_count = 0usize;
    let ubuntu_assets_ok = check_ubuntu_assets(&config.pxe_assets_dir).await;
    let ubuntu_hosts = hosts
        .iter()
        .filter(|host| {
            host.os_type
                .as_deref()
                .map(str::trim)
                .map(|value| value.eq_ignore_ascii_case("ubuntu"))
                .unwrap_or(false)
        })
        .count();
    if ubuntu_hosts > 0 && !ubuntu_assets_ok {
        let warning = "Ubuntu PXE-Assets fehlen unter PXE_ASSETS_DIR".to_string();
        warnings.push(warning.clone());
        tracing::warn!("{}", warning);
        missing_assets_count = ubuntu_hosts;
    }

    let pxe_configs_dir = pxe::ensure_ipxe_configs_dir(config)
        .await
        .context("failed to ensure ipxe configs directory")?;

    for host in &hosts {
        let host_label = host
            .hostname
            .as_deref()
            .map(str::trim)
            .filter(|v| !v.is_empty())
            .unwrap_or(host.mac_address.trim());
        tracing::debug!(
            host = %host_label,
            pxe_enabled = host.pxe_enabled,
            "processing host for dnsmasq"
        );
        let mac = MacAddr::from_str(host.mac_address.trim()).with_context(|| {
            format!("invalid mac_address in hosts table: {}", host.mac_address)
        })?;
        let host_tag = mac.to_string();
        let subnet_tag = subnet_tag(&host.subnet_name, &host.subnet_network_start);
        let mut content = String::new();
        content.push_str(&format!("dhcp-host={},{}", host_tag, host.ip_address));
        if let Some(name) = host.hostname.as_deref().map(str::trim).filter(|v| !v.is_empty()) {
            content.push_str(&format!(",{}", name));
        }
        content.push_str(&format!(",set:{},set:{}\n", subnet_tag, host_tag));
        if let Some(name) = host.hostname.as_deref().map(str::trim).filter(|v| !v.is_empty()) {
            if name.chars().any(|c| c.is_whitespace()) {
                tracing::warn!(
                    hostname = %name,
                    "hostname contains whitespace; skipping address record"
                );
            } else {
                content.push_str(&format!("address=/{}/{}\n", name, host.ip_address));
            }
        }
        if let Some(gateway) = host.gateway.as_deref().map(str::trim).filter(|v| !v.is_empty()) {
            content.push_str(&format!(
                "dhcp-option=tag:{},option:router,{}\n",
                subnet_tag, gateway
            ));
        }
        if let Some(dns_primary) = host.dns_primary.as_deref().map(str::trim).filter(|v| !v.is_empty()) {
            content.push_str(&format!(
                "dhcp-option=tag:{},option:dns-server,{}\n",
                subnet_tag, dns_primary
            ));
        } else if let Some(gateway) = host.gateway.as_deref().map(str::trim).filter(|v| !v.is_empty()) {
            content.push_str(&format!(
                "dhcp-option=tag:{},option:dns-server,{}\n",
                subnet_tag, gateway
            ));
        }
        content.push_str(&format!("dhcp-boot=tag:{},{}\n", host_tag, ipxe_boot));

        let file_path =
            Path::new(&config.dnsmasq_conf_dir).join(format!("host_{}.conf", host_tag));
        tokio::fs::write(&file_path, content)
            .await
            .with_context(|| format!("failed to write dnsmasq host file {}", file_path.display()))?;

        let host_pxe = HostPxe {
            mac_address: host.mac_address.clone(),
            os_type: host.os_type.clone(),
        };
        pxe::write_ipxe_config(&host_pxe, &pxe_configs_dir)
            .await
            .context("failed to write ipxe config")?;
    }

    let warnings_count = warnings.len();
    update_warnings(status, warnings).await;

    tracing::info!(
        path = %config.dnsmasq_conf_dir,
        "dnsmasq host configs written"
    );

    match TokioCommand::new("dnsmasq")
        .arg("--test")
        .arg("--conf-file=/etc/dnsmasq.conf")
        .output()
        .await
    {
        Ok(output) => {
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                tracing::error!(
                    status = %output.status,
                    stderr = %stderr,
                    "dnsmasq --test failed"
                );
                update_last_test(status, false, Some(stderr.to_string())).await;
                let cfg = config.clone();
                let body = format!("dnsmasq --test ist fehlgeschlagen:\n{stderr}");
                tokio::spawn(async move {
                    if let Err(e) = email::send_admin_alert(
                        &cfg,
                        "ipmanager: dnsmasq --test fehlgeschlagen",
                        &body,
                    )
                    .await
                    {
                        tracing::error!(error = ?e, "failed to send dnsmasq test email alert");
                    }
                });
                return Err(anyhow::anyhow!("dnsmasq --test failed: {}", stderr));
            }
            update_last_test(status, true, None).await;
        }
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            tracing::error!("dnsmasq binary not found; cannot run dnsmasq --test");
            update_last_test(status, false, Some("dnsmasq binary not found".to_string())).await;
            return Err(e).context("dnsmasq binary not found");
        }
        Err(e) => {
            tracing::error!(error = ?e, "failed to execute dnsmasq --test");
            update_last_test(status, false, Some(format!("{:?}", e))).await;
            return Err(e).context("failed to execute dnsmasq --test");
        }
    }

    let reload_status = tokio::task::spawn_blocking(|| {
        StdCommand::new("sudo")
            .arg("systemctl")
            .arg("restart")
            .arg("dnsmasq")
            .status()
    })
    .await
    .context("failed to join dnsmasq restart task")?
    .context("failed to execute dnsmasq restart command")?;

    if !reload_status.success() {
        tracing::error!(
            status = %reload_status,
            command = "sudo systemctl restart dnsmasq",
            "dnsmasq reload command failed"
        );
        let cfg = config.clone();
        let body = format!(
            "dnsmasq reload command failed: {}\ncommand: {}",
            reload_status, "sudo systemctl restart dnsmasq"
        );
        tokio::spawn(async move {
            if let Err(e) = email::send_admin_alert(
                &cfg,
                "ipmanager: dnsmasq restart fehlgeschlagen",
                &body,
            )
            .await
            {
                tracing::error!(error = ?e, "failed to send dnsmasq restart email alert");
            }
        });
        return Err(anyhow::anyhow!(
            "dnsmasq reload command failed with status: {reload_status}"
        ));
    }

    {
        let mut guard = status.lock().await;
        guard.last_restart_at = Some(Utc::now());
    }

    let details: JsonValue = serde_json::json!({
        "hosts_updated": hosts.len(),
        "warnings_count": warnings_count,
        "has_orphans": missing_assets_count > 0,
    });
    if let Err(e) = sqlx::query(
        "insert into audit_logs (user_id, action, details) values ($1, $2, $3)",
    )
    .bind(user_id)
    .bind("dnsmasq_sync")
    .bind(details)
    .execute(pool)
    .await
    {
        tracing::error!(error = ?e, "failed to write audit log for dnsmasq sync");
    }

    if missing_assets_count > 0 {
        let subject = "ipmanager: fehlende PXE-Dateien beim dnsmasq Sync";
        let body = format!(
            "Beim dnsmasq Sync wurden {missing_assets_count} Hosts mit fehlenden PXE-Dateien festgestellt.\n\
Bitte pruefe die PXE-Assets unter {}.",
            config.pxe_assets_dir
        );
        let cfg = config.clone();
        tokio::spawn(async move {
            if let Err(e) = email::send_admin_alert(&cfg, subject, &body).await {
                tracing::error!(error = ?e, "failed to send orphaned PXE email alert");
            }
        });
    }

    if config.macmon_enabled {
        if let Err(e) = macmon::sync_new_hosts(pool, config).await {
            tracing::error!(error = ?e, "macmon sync failed");
        }
    } else {
        tracing::debug!("macmon sync disabled; skipping");
    }

    tracing::info!(
        command = "sudo systemctl restart dnsmasq",
        "dnsmasq reload command succeeded"
    );

    Ok(())
}

async fn check_infrastructure(tftp_root: &Path) -> Result<()> {
    if let Err(e) = tokio::fs::create_dir_all(tftp_root).await {
        tracing::error!(error = ?e, path = %tftp_root.display(), "failed to create tftp root");
        return Err(e).context("failed to create tftp root");
    }

    let permissions = std::fs::Permissions::from_mode(0o755);
    if let Err(e) = tokio::fs::set_permissions(tftp_root, permissions).await {
        if e.kind() == std::io::ErrorKind::PermissionDenied {
            tracing::warn!(
                error = ?e,
                path = %tftp_root.display(),
                "permission denied while setting tftp root permissions"
            );
            if tokio::fs::read_dir(tftp_root).await.is_err() {
                return Err(e).context("tftp root is not readable");
            }
        } else {
            tracing::error!(
                error = ?e,
                path = %tftp_root.display(),
                "failed to set tftp root permissions"
            );
            return Err(e).context("failed to set tftp root permissions");
        }
    }

    Ok(())
}

async fn ensure_dnsmasq_conf_dir(conf_dir: &Path) -> Result<()> {
    if let Err(e) = tokio::fs::create_dir_all(conf_dir).await {
        tracing::error!(error = ?e, path = %conf_dir.display(), "failed to create dnsmasq conf dir");
        return Err(e).context("failed to create dnsmasq conf dir");
    }
    Ok(())
}

async fn clean_host_configs(conf_dir: &Path) -> Result<()> {
    let mut entries = tokio::fs::read_dir(conf_dir)
        .await
        .with_context(|| format!("failed to read dnsmasq conf dir {}", conf_dir.display()))?;
    while let Ok(Some(entry)) = entries.next_entry().await {
        let path = entry.path();
        if !path.is_file() {
            continue;
        }
        let name = match path.file_name().and_then(|v| v.to_str()) {
            Some(v) => v,
            None => continue,
        };
        if name.starts_with("host_") && name.ends_with(".conf") {
            tokio::fs::remove_file(&path)
                .await
                .with_context(|| format!("failed to remove {}", path.display()))?;
        }
    }
    Ok(())
}

async fn write_subnet_configs(
    ranges: &[DhcpRangeRow],
    conf_dir: &Path,
    config: &crate::config::Config,
) -> Result<()> {
    clean_subnet_configs(conf_dir).await?;
    for range in ranges {
        let tag = subnet_tag(&range.name, &range.network_start);
        let file_stub = sanitize_dnsmasq_name(&range.name);
        let file_path = conf_dir.join(format!("subnet_{}.conf", file_stub));
        let mut content = format!(
            "dhcp-range=set:{},{},static,{},12h\n",
            tag, range.network_start, range.netmask
        );
        let gateway = range
            .gateway
            .as_deref()
            .map(str::trim)
            .filter(|v| !v.is_empty())
            .map(|v| v.to_string())
            .or_else(|| default_gateway(&range.network_start));
        if let Some(gateway) = gateway {
            content.push_str(&format!(
                "dhcp-option=tag:{},option:router,{}\n",
                tag, gateway
            ));
        }
        let dns_server = range
            .dns_primary
            .as_deref()
            .map(str::trim)
            .filter(|v| !v.is_empty())
            .unwrap_or_else(|| config.ipmanager_ip.trim());
        content.push_str(&format!(
            "dhcp-option=tag:{},option:dns-server,{}\n",
            tag, dns_server
        ));
        let domain_suffix = config.domain_name.trim();
        content.push_str(&format!(
            "dhcp-option=tag:{},option:domain-name,\"{}\"\n",
            tag, domain_suffix
        ));
        let ntp_server = range
            .ntp_server
            .as_deref()
            .map(str::trim)
            .filter(|v| !v.is_empty())
            .unwrap_or("0.0.0.0");
        content.push_str(&format!("dhcp-option=tag:{},42,{}\n", tag, ntp_server));
        tokio::fs::write(&file_path, content)
            .await
            .with_context(|| format!("failed to write dnsmasq subnet file {}", file_path.display()))?;
    }
    Ok(())
}

async fn clean_subnet_configs(conf_dir: &Path) -> Result<()> {
    let mut entries = tokio::fs::read_dir(conf_dir)
        .await
        .with_context(|| format!("failed to read dnsmasq conf dir {}", conf_dir.display()))?;
    while let Ok(Some(entry)) = entries.next_entry().await {
        let path = entry.path();
        if !path.is_file() {
            continue;
        }
        let name = match path.file_name().and_then(|v| v.to_str()) {
            Some(v) => v,
            None => continue,
        };
        if name.starts_with("subnet_") && name.ends_with(".conf") {
            tokio::fs::remove_file(&path)
                .await
                .with_context(|| format!("failed to remove {}", path.display()))?;
        }
    }
    Ok(())
}

fn subnet_tag(name: &str, network_start: &str) -> String {
    let network = sanitize_dnsmasq_name(network_start);
    if !network.is_empty() {
        return network;
    }
    sanitize_dnsmasq_name(name)
}

fn default_gateway(network_start: &str) -> Option<String> {
    let parts: Vec<&str> = network_start.trim().split('.').collect();
    if parts.len() != 4 {
        return None;
    }
    if parts.iter().any(|part| part.parse::<u8>().is_err()) {
        return None;
    }
    Some(format!("{}.{}.{}.1", parts[0], parts[1], parts[2]))
}

fn sanitize_dnsmasq_name(value: &str) -> String {
    let mut out = String::new();
    for ch in value.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(ch.to_ascii_lowercase());
        } else if !out.ends_with('_') {
            out.push('_');
        }
    }
    out.trim_matches('_').to_string()
}

fn assets_relative_path(config: &crate::config::Config) -> String {
    let tftp_root = Path::new(&config.tftp_root_dir);
    let assets_dir = Path::new(&config.pxe_assets_dir);
    let rel = assets_dir
        .strip_prefix(tftp_root)
        .ok()
        .and_then(|path| path.to_str())
        .map(|v| v.trim_start_matches('/').to_string());
    rel.filter(|v| !v.is_empty())
        .unwrap_or_else(|| "pxe-assets".to_string())
}

async fn check_ubuntu_assets(pxe_assets_dir: &str) -> bool {
    let base = Path::new(pxe_assets_dir).join("ubuntu");
    let kernel = base.join("vmlinuz");
    let initrd = base.join("initrd.img");
    let kernel_ok = tokio::fs::try_exists(&kernel).await.unwrap_or(false);
    let initrd_ok = tokio::fs::try_exists(&initrd).await.unwrap_or(false);
    kernel_ok && initrd_ok
}

pub async fn record_sync_error(status: &Mutex<DnsmasqStatus>, message: String) {
    let mut guard = status.lock().await;
    guard.warnings = vec![message];
}

async fn update_last_test(
    status: &Mutex<DnsmasqStatus>,
    ok: bool,
    stderr: Option<String>,
) {
    let mut guard = status.lock().await;
    guard.last_test = Some(DnsmasqTestResult {
        ok,
        stderr,
        at: Utc::now(),
    });
}

async fn update_warnings(status: &Mutex<DnsmasqStatus>, warnings: Vec<String>) {
    let mut guard = status.lock().await;
    guard.warnings = warnings;
}
