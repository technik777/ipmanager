use anyhow::{Context, Result};
use sqlx::{FromRow, PgPool};
use tokio::process::Command;

use crate::domain::mac::MacAddr;
const DNSMASQ_GLOBAL_CONFIG_PATH: &str = "/etc/dnsmasq.d/00-global.conf";

#[derive(Debug, FromRow)]
struct HostRow {
    mac_address: String,
    ip_address: String,
    hostname: Option<String>,
}

#[derive(Debug, FromRow)]
struct DhcpRangeRow {
    dhcp_pool_start: String,
    dhcp_pool_end: String,
}

pub async fn generate_global_config(pool: &PgPool, config: &crate::config::Config) -> Result<()> {
    match tokio::fs::try_exists(DNSMASQ_GLOBAL_CONFIG_PATH).await {
        Ok(true) => return Ok(()),
        Ok(false) => {}
        Err(e) => {
            tracing::error!(
                error = ?e,
                path = DNSMASQ_GLOBAL_CONFIG_PATH,
                "failed to check dnsmasq global config path"
            );
            return Err(e).context("failed to check dnsmasq global config path");
        }
    }

    let ranges: Vec<DhcpRangeRow> = match sqlx::query_as(
        "select host(dhcp_pool_start) as dhcp_pool_start, host(dhcp_pool_end) as dhcp_pool_end
         from subnets
         where dhcp_enabled = true
           and dhcp_pool_start is not null
           and dhcp_pool_end is not null
         order by name",
    )
    .fetch_all(pool)
    .await
    {
        Ok(rows) => rows,
        Err(e) => {
            tracing::error!(error = ?e, "failed to load DHCP ranges for dnsmasq");
            return Err(e).context("failed to load DHCP ranges for dnsmasq");
        }
    };

    let mut output = String::new();
    output.push_str("# Generated by ipmanager\n");
    output.push_str(&format!(
        "listen-address={}\n",
        config.dnsmasq_bind_addr
    ));
    let interface = config
        .dnsmasq_interface
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .unwrap_or("lo");
    output.push_str(&format!("interface={interface}\n"));
    output.push_str("bind-interfaces\n");
    output.push_str(&format!("port={}\n", config.dnsmasq_port));
    output.push_str("dhcp-authoritative\n");
    for range in ranges {
        output.push_str(&format!(
            "dhcp-range={},{}\n",
            range.dhcp_pool_start, range.dhcp_pool_end
        ));
    }

    if let Err(e) = tokio::fs::write(DNSMASQ_GLOBAL_CONFIG_PATH, output).await {
        tracing::error!(
            error = ?e,
            path = DNSMASQ_GLOBAL_CONFIG_PATH,
            "failed to write dnsmasq global config"
        );
        return Err(e).context("failed to write dnsmasq global config");
    }

    tracing::info!(
        path = DNSMASQ_GLOBAL_CONFIG_PATH,
        "dnsmasq global config written"
    );

    Ok(())
}

pub async fn sync_dnsmasq_hosts(pool: &PgPool, config: &crate::config::Config) -> Result<()> {
    generate_global_config(pool, config).await?;

    let hosts: Vec<HostRow> = match sqlx::query_as(
        "select mac_address::text as mac_address, host(ip_address) as ip_address, hostname from hosts",
    )
    .fetch_all(pool)
    .await
    {
        Ok(rows) => rows,
        Err(e) => {
            tracing::error!(error = ?e, "failed to fetch hosts for dnsmasq sync");
            return Err(e).context("failed to fetch hosts for dnsmasq sync");
        }
    };

    let mut output = String::new();
    output.push_str("dhcp-ignore=tag:!known_host\n");
    if config.pxe_enabled {
        let boot_url = format!(
            "{}/boot.ipxe",
            config.base_url.as_str().trim_end_matches('/')
        );
        output.push_str("# iPXE Filter & Boot-Steuerung\n");
        output.push_str("dhcp-userclass=set:ipxe,iPXE\n");
        output.push_str("dhcp-boot=tag:!ipxe,ipxe.efi\n");
        output.push_str(&format!("dhcp-boot=tag:ipxe,{}\n", boot_url));
        output.push_str("enable-tftp\n");
        output.push_str(&format!("tftp-root={}\n\n", config.pxe_root_dir));
    }
    for host in hosts {
        let mac = MacAddr::from_str(host.mac_address.trim()).with_context(|| {
            format!("invalid mac_address in hosts table: {}", host.mac_address)
        })?;
        output.push_str(&format!(
            "dhcp-host={},{},set:known_host\n",
            mac, host.ip_address
        ));
    }

    if let Err(e) = tokio::fs::write(&config.dnsmasq_hosts_file, output).await {
        tracing::error!(
            error = ?e,
            path = %config.dnsmasq_hosts_file,
            "failed to write dnsmasq hosts file"
        );
        return Err(e).with_context(|| {
            format!(
                "failed to write dnsmasq hosts file to {}",
                config.dnsmasq_hosts_file
            )
        });
    }

    tracing::info!(
        path = %config.dnsmasq_hosts_file,
        "dnsmasq hosts file written"
    );

    match Command::new("dnsmasq").arg("--test").output().await {
        Ok(output) => {
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                tracing::error!(
                    status = %output.status,
                    stderr = %stderr,
                    "dnsmasq --test failed"
                );
                return Err(anyhow::anyhow!("dnsmasq --test failed: {}", stderr));
            }
        }
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            tracing::info!("dnsmasq binary not found; skipping dnsmasq --test");
        }
        Err(e) => {
            tracing::error!(error = ?e, "failed to execute dnsmasq --test");
            return Err(e).context("failed to execute dnsmasq --test");
        }
    }

    let status = match Command::new("sh")
        .arg("-c")
        .arg(&config.dnsmasq_reload_cmd)
        .status()
        .await
    {
        Ok(s) => s,
        Err(e) => {
            tracing::error!(
                error = ?e,
                command = %config.dnsmasq_reload_cmd,
                "failed to execute dnsmasq reload command"
            );
            return Err(e).context("failed to execute dnsmasq reload command");
        }
    };

    if !status.success() {
        tracing::error!(
            status = %status,
            command = %config.dnsmasq_reload_cmd,
            "dnsmasq reload command failed"
        );
        return Err(anyhow::anyhow!(
            "dnsmasq reload command failed with status: {status}"
        ));
    }

    tracing::info!(
        command = %config.dnsmasq_reload_cmd,
        "dnsmasq reload command succeeded"
    );

    Ok(())
}
